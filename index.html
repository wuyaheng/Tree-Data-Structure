<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Intro to Tree Data Structure</title> 
    
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" crossorigin="anonymous">
    <link rel='stylesheet' type='text/css' href='https://fonts.googleapis.com/css?family=Playfair+Display:700,400,900,400italic,700italic,900italic|Merriweather:400,300,700,900,300italic,400italic,700italic,900italic|Anonymous+Pro:400,700,400italic,700italic|Roboto:400,700' />
    <link rel='stylesheet' type='text/css' href='https://cdn.rawgit.com/google/code-prettify/master/styles/desert.css' />
    <link rel='stylesheet' type='text/css' href='https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css' />


<style>
body {
  margin:50px 10px;
}

#blog {
  display: block; 
  width: auto!important; 
  overflow: hidden; 
} 

a, a.named_anchor {
    text-decoration: inherit;
    font-style: inherit;
    color: inherit;
  }
  


h1 {
    letter-spacing: -0.06em;
    margin-bottom: 0.05em;
    line-height: 1em;
}

.byline {
    font: normal normal 400 1.3em;
    margin-bottom: .8em;
    letter-spacing: -0.04em;
  }

.pubdate {
    font: normal normal 400 1em;
    text-transform: uppercase;
    margin-bottom: 1em;
  }

.pubtime:before {
    font-family: 'FontAwesome';
    font-size: .8em;
    content:'\f054';
    margin: 0em .5em;
}

hr {
    border: 0;
    border-bottom: 4px double;
    height: 0.15em;
}


.topic {
    font: normal normal 900 .8em;
    text-transform: uppercase;
    margin-bottom: 1em;
  }

#article {
  font: normal normal 400 1em/2em;
  line-height: 2em;
  text-align: justify;
}

a, a:link {
    text-decoration: none;
    cursor: pointer;
    color: #1b98e0;
}  

.shade {
  background: #eee;
  padding: 0 0.2em;
}
    
h2, h3, h4, h5 { 
    font-weight: 650; 
    font-size: 1.25em; 
}


p { 
    margin-bottom:2em; 
    line-height: 2em;
}
    

/* p:first-child:first-letter { 
      font-weight: 900;
      float: left; 
      font-size: 4em; 
      line-height: 1em; 
      padding: 0em 0.1em 0em 0em;
} */

pre {
    background: #f4f4f4;
    border: 1px solid #ddd;
    border-left: 3px solid #F2957E;
    color: #666;
    page-break-inside: avoid;
    font-family: monospace;
    font-size: 15px;
    line-height: 1.6;
    margin-bottom: 1.6em;
    max-width: 100%;
    overflow: auto;
    padding: 1em 1.5em;
    display: block;
    word-wrap: break-word;
}

pre span {
  color: #339b4b;
}

.slideSample {
  width: 50%;
}

@media only screen and (max-width: 768px) {
  .slideSample {
    width: 80%;
  }
}

    </style>
</head>
<body>
    


    
<div class="container">
    <div id="blog">
      <div id="title">
        <div class="pubdate">10 May 2022<hr/></div>
        <h1>Intro to Tree Data Structure</h1>
        <div class="byline">by Phoebe Yaheng Wu</div> 
        <!-- <div class="topic">Data</div> -->
      </div>
      
    
      
      <!-- Article text -->
      <!-- <a class="named_anchor" name="2549202418499648455"></a> -->
      <div id="article">
        <div id="content"> 
          <p>In this blog, I will share with you what you need to know about tree data structure and how to traverse through trees.</p>

          <p>The tree data structure consists of nodes and edges. The root node is the uppermost node on a tree. It’s the most powerful node, and we can access each node of the tree from this node. Each node is connected through edges. Leaf nodes are the bottom-most nodes that don’t have any children. A tree can also consist of multiple subtrees with a similar structure of a parent at the top and the children directly below it. You can get a clear view of a tree data structure through the graph below:</p>

          <div class="row justify-content-center"><img class="slideSample" src="./assets/tree.jpg"/></div>

          <p>In a non-linear data structure like a tree, we have different ways to reach a node. These include in-order traversal, pre-order traversal, and post-order traversal. The key difference among them is when to visit the root node in relation to the left node and right node. Regardless of the traversal method, the left node always comes before the right node.</p>
        
          <div class="row justify-content-center"><img class="slideSample" src="./assets/traversal.jpg"/></div>
        
          <p>Below is a list of practice problems from Leetcode about the tree data structure. Viewing and practicing these problems will help you better understand what the tree data structure is and how tree traversal works.</p>

          <p class="text-center text-muted"><a href="https://leetcode.com/problems/binary-tree-preorder-traversal/" target="_blank">https://leetcode.com/problems/binary-tree-preorder-traversal/</a></p>
<pre>
class Solution:
  def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
      ans = []
      stack = [root]
      
      if root is None:
          return ans
      
      while stack:
          cur = stack.pop()

          if cur != None:
              if (cur.right != None):
                  stack.append(cur.right)
                  
              if (cur.left != None):
                  stack.append(cur.left)
                  
              stack.append(cur)
              stack.append(None)
              
          else:
              ans.append(stack.pop().val)
              
      return ans
</pre>

  <p class="text-center text-muted"><a href="https://leetcode.com/problems/binary-tree-postorder-traversal/" target="_blank">https://leetcode.com/problems/binary-tree-postorder-traversal/</a></p>
<pre>
class Solution:
  def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
      ans = []
      stack = [root]
      
      if root is None:
          return ans
      
      while stack:
          cur = stack.pop()
          
          if cur != None:
              stack.append(cur)
              stack.append(None)
              
              if (cur.right != None):
                  stack.append(cur.right)
                  
              if (cur.left != None):
                  stack.append(cur.left)
          else:
              ans.append(stack.pop().val)
              
      return ans
</pre>

  <p class="text-center text-muted"><a href="https://leetcode.com/problems/binary-tree-inorder-traversal/" target="_blank">https://leetcode.com/problems/binary-tree-inorder-traversal/</a></p> 
<pre>
class Solution:
  def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
      ans = []
      stack = [root]
      
      if root is None:
          return ans
      
      while stack:
          cur = stack.pop()
          
          if cur != None:
              if cur.right != None:
                  stack.append(cur.right)

              stack.append(cur)
              stack.append(None)

              if cur.left != None:
                  stack.append(cur.left)
          else:
              ans.append(stack.pop().val)
              
      return ans
</pre>

<p class="text-center text-muted"><a href="https://leetcode.com/problems/binary-tree-level-order-traversal/" target="_blank">https://leetcode.com/problems/binary-tree-level-order-traversal/</a></p> 
<pre>
class Solution:
  def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:        
      ans = []
      
      if root is None:
          return ans
      
      q = deque([root])

      while q:
          
          level = []
          
          for _ in range(len(q)):
              
              node = q.popleft()
              level.append(node.val)
              
              if node.left:
                  q.append(node.left)
                  
              if node.right:
                  q.append(node.right)
                  
          ans.append(level)
      
      return ans
</pre>

<p class="text-center text-muted"><a href="https://leetcode.com/problems/binary-tree-level-order-traversal-ii/" target="_blank">https://leetcode.com/problems/binary-tree-level-order-traversal-ii/</a></p> 
<pre>
class Solution:
  def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:
      ans = []
      
      if root is None:
          return ans
      
      q = deque([root])

      while q:
          
          level = []
          
          for _ in range(len(q)):
              
              node = q.popleft()      
              level.append(node.val)
              
              if node.left:
                  q.append(node.left)
                  
              if node.right:
                  q.append(node.right)
                  
          ans.append(level)
          
      return ans[::-1]
</pre>

<p class="text-center text-muted"><a href="https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/" target="_blank">https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/</a></p> 
<pre>
class Solution:
  def zigzagLevelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
      ans = []
      
      if root is None:
          return ans
      
      q = deque([root])

      left_to_right = True
      
      while q:
          level = []
          for _ in range(len(q)):
              
              node = q.popleft()
              level.append(node.val)
                  
              if node.left:
                  q.append(node.left)
              
              if node.right:
                  q.append(node.right)
                  
          if left_to_right:        
              ans.append(level)

          else:
              ans.append(level[::-1])
              
          left_to_right = not left_to_right
          
      return ans
</pre>

<p class="text-center text-muted"><a href="https://leetcode.com/problems/n-ary-tree-level-order-traversal/" target="_blank">https://leetcode.com/problems/n-ary-tree-level-order-traversal/</a></p> 
<pre>
class Solution:
  def levelOrder(self, root: 'Node') -> List[List[int]]:
      ans = []
      
      if root is None:
          return ans
      
      q = deque([root])
      
      while q:
          
          level = []
          for i in range(len(q)):
              
              cur = q.popleft()
              level.append(cur.val)  
              
              for child in cur.children:
                  q.append(child)
  
          ans.append(level)
          
      return ans
</pre>


<p class="text-center text-muted"><a href="https://leetcode.com/problems/check-completeness-of-a-binary-tree/" target="_blank">https://leetcode.com/problems/check-completeness-of-a-binary-tree/</a></p> 
<pre>
class Solution:
  def isCompleteTree(self, root: Optional[TreeNode]) -> bool:
      q = deque([root])
      
      zero = False
      
      while q:
          cur = q.popleft()
          
          if cur is None:
              zero = True
          
          if zero and cur != None:
              return False
          
          if cur != None:
              q.append(cur.left)
              q.append(cur.right)
              
      return True
</pre>
 
</div>
      </div>
    </div>

    <!-- Footer -->
    <footer class="page-footer font-small blue pt-4">
  
      <!-- Copyright -->
      <div class="footer-copyright text-center py-3">
        
        <div id="disqus_thread"></div>
      </div>
      <!-- Copyright -->
    
    </footer>
    <!-- Footer -->
    
    </div>
    <!-- Scripts --> 

    <script src="https://cdn.rawgit.com/google/code-prettify/master/loader/prettify.js"></script>
    <!-- Script for pocket button -->
    <script type="text/javascript">!function(d,i){if(!d.getElementById(i)){var j=d.createElement("script");j.id=i;j.src="https://widgets.getpocket.com/v1/j/btn.js?v=1";var w=d.getElementById(i);d.body.appendChild(j);}}(document,"pocket-btn-js");</script>
    <!-- Print friendly -->
    <script>var pfHeaderImgUrl = '';var pfHeaderTagline = '';var pfdisableClickToDel = 0;var pfHideImages = 0;var pfImageDisplayStyle = 'right';var pfDisablePDF = 0;var pfDisableEmail = 0;var pfDisablePrint = 0;var pfCustomCSS = '';var pfBtVersion='1';(function(){var js, pf;pf = document.createElement('script');pf.type = 'text/javascript';if ('https:' === document.location.protocol){js='https://pf-cdn.printfriendly.com/ssl/main.js'}else{js='http://cdn.printfriendly.com/printfriendly.js'}pf.src=js;document.getElementsByTagName('head')[0].appendChild(pf)})();</script>
    <!-- Share button / http://sharebutton.co
    <script src="https://cdn.rawgit.com/carrot/share-button/master/src/share-button.js"></script>-->


    <script>
      /**
      *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
      *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables    */
      /*
      var disqus_config = function () {
      this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
      this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
      };
      */
      (function() { // DON'T EDIT BELOW THIS LINE
      var d = document, s = d.createElement('script');
      s.src = 'https://wuyaheng.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
      })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</body>
</html>


