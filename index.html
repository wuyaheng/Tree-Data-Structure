<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Intro to Tree Data Structure</title> 
    
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" crossorigin="anonymous">
    <link rel='stylesheet' type='text/css' href='https://fonts.googleapis.com/css?family=Playfair+Display:700,400,900,400italic,700italic,900italic|Merriweather:400,300,700,900,300italic,400italic,700italic,900italic|Anonymous+Pro:400,700,400italic,700italic|Roboto:400,700' />
    <link rel='stylesheet' type='text/css' href='https://cdn.rawgit.com/google/code-prettify/master/styles/desert.css' />
    <link rel='stylesheet' type='text/css' href='https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css' />


<style>
body {
  margin:50px 10px;
}

#blog {
  display: block; 
  width: auto!important; 
  overflow: hidden; 
} 

a, a.named_anchor {
    text-decoration: inherit;
    font-style: inherit;
    color: inherit;
  }
  


h1 {
    letter-spacing: -0.06em;
    margin-bottom: 0.05em;
    line-height: 1em;
}

.byline {
    font: normal normal 400 1.3em;
    margin-bottom: .8em;
    letter-spacing: -0.04em;
  }

.pubdate {
    font: normal normal 400 1em;
    text-transform: uppercase;
    margin-bottom: 1em;
  }

.pubtime:before {
    font-family: 'FontAwesome';
    font-size: .8em;
    content:'\f054';
    margin: 0em .5em;
}

hr {
    border: 0;
    border-bottom: 4px double;
    height: 0.15em;
}


.topic {
    font: normal normal 900 .8em;
    text-transform: uppercase;
    margin-bottom: 1em;
  }

#article {
  font: normal normal 400 1em/2em;
  line-height: 2em;
  text-align: justify;
}

a, a:link {
    text-decoration: none;
    cursor: pointer;
    color: #1b98e0;
}  

.shade {
  background: #eee;
  padding: 0 0.2em;
}
    
h2, h3, h4, h5 { 
    font-weight: 650; 
    font-size: 1.25em; 
}


p { 
    margin-bottom:2em; 
    line-height: 2em;
}
    

/* p:first-child:first-letter { 
      font-weight: 900;
      float: left; 
      font-size: 4em; 
      line-height: 1em; 
      padding: 0em 0.1em 0em 0em;
} */

pre {
    background: #f4f4f4;
    border: 1px solid #ddd;
    border-left: 3px solid #F2957E;
    color: #666;
    page-break-inside: avoid;
    font-family: monospace;
    font-size: 15px;
    line-height: 1.6;
    margin-bottom: 1.6em;
    max-width: 100%;
    overflow: auto;
    padding: 1em 1.5em;
    display: block;
    word-wrap: break-word;
}

pre span {
  color: #339b4b;
}

.slideSample {
  width: 50%;
}

@media only screen and (max-width: 768px) {
  .slideSample {
    width: 80%;
  }
}

    </style>
</head>
<body>
    


    
<div class="container">
    <div id="blog">
      <div id="title">
        <div class="pubdate">10 May 2022<hr/></div>
        <h1>Intro to Tree Data Structure</h1>
        <div class="byline">by Phoebe Yaheng Wu</div> 
        <!-- <div class="topic">Data</div> -->
      </div>
      
    
      
      <!-- Article text -->
      <!-- <a class="named_anchor" name="2549202418499648455"></a> -->
      <div id="article">
        <div id="content"> 
          <p>In this blog, I will share with you what you need to know about tree data structure and how to traverse through trees.</p>

          <p>The tree data structure consists of nodes and edges. The root node is the uppermost node on a tree. It’s the most powerful node, and we can access each node of the tree from this node. Each node is connected through edges. Leaf nodes are the bottom-most nodes that don’t have any children. A tree can also consist of multiple subtrees with a similar structure of a parent at the top and the children directly below it. You can get a clear view of a tree data structure through the graph below:</p>

          <div class="row justify-content-center"><img class="slideSample" src="./assets/tree.jpg"/></div>

          <p>In a non-linear data structure like a tree, we have different ways to reach a node. These include in-order traversal, pre-order traversal, and post-order traversal. The key difference among them is when to visit the root node in relation to the left node and right node. Regardless of the traversal method, the left node always comes before the right node.</p>
        
          <div class="row justify-content-center"><img class="slideSample" src="./assets/traversal.jpg"/></div>
        
          <p>Below is a list of practice problems from Leetcode about the tree data structure. Viewing and practicing these problems will help you better understand what the tree data structure is and how tree traversal works.</p>

          <p class="text-center text-muted"><a href="https://leetcode.com/problems/binary-tree-preorder-traversal/" target="_blank">https://leetcode.com/problems/binary-tree-preorder-traversal/</a></p>
<pre>
class Solution:
  def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
      ans = []
      stack = [root]
      
      if root is None:
          return ans
      
      while stack:
          cur = stack.pop()

          if cur != None:
              if (cur.right != None):
                  stack.append(cur.right)
                  
              if (cur.left != None):
                  stack.append(cur.left)
                  
              stack.append(cur)
              stack.append(None)
              
          else:
              ans.append(stack.pop().val)
              
      return ans
</pre>

  <p class="text-center text-muted"><a href="https://leetcode.com/problems/binary-tree-postorder-traversal/" target="_blank">https://leetcode.com/problems/binary-tree-postorder-traversal/</a></p>
<pre>
class Solution:
  def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
      ans = []
      stack = [root]
      
      if root is None:
          return ans
      
      while stack:
          cur = stack.pop()
          
          if cur != None:
              stack.append(cur)
              stack.append(None)
              
              if (cur.right != None):
                  stack.append(cur.right)
                  
              if (cur.left != None):
                  stack.append(cur.left)
          else:
              ans.append(stack.pop().val)
              
      return ans
</pre>

  <p class="text-center text-muted"><a href="https://leetcode.com/problems/binary-tree-inorder-traversal/" target="_blank">https://leetcode.com/problems/binary-tree-inorder-traversal/</a></p> 
<pre>
class Solution:
  def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
      ans = []
      stack = [root]
      
      if root is None:
          return ans
      
      while stack:
          cur = stack.pop()
          
          if cur != None:
              if cur.right != None:
                  stack.append(cur.right)

              stack.append(cur)
              stack.append(None)

              if cur.left != None:
                  stack.append(cur.left)
          else:
              ans.append(stack.pop().val)
              
      return ans
</pre>

<p class="text-center text-muted"><a href="https://leetcode.com/problems/binary-tree-level-order-traversal/" target="_blank">https://leetcode.com/problems/binary-tree-level-order-traversal/</a></p> 
<pre>
class Solution:
  def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:        
      ans = []
      
      if root is None:
          return ans
      
      q = deque([root])

      while q:
          
          level = []
          
          for _ in range(len(q)):
              
              node = q.popleft()
              level.append(node.val)
              
              if node.left:
                  q.append(node.left)
                  
              if node.right:
                  q.append(node.right)
                  
          ans.append(level)
      
      return ans
</pre>

<p class="text-center text-muted"><a href="https://leetcode.com/problems/binary-tree-level-order-traversal-ii/" target="_blank">https://leetcode.com/problems/binary-tree-level-order-traversal-ii/</a></p> 
<pre>
class Solution:
  def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:
      ans = []
      
      if root is None:
          return ans
      
      q = deque([root])

      while q:
          
          level = []
          
          for _ in range(len(q)):
              
              node = q.popleft()      
              level.append(node.val)
              
              if node.left:
                  q.append(node.left)
                  
              if node.right:
                  q.append(node.right)
                  
          ans.append(level)
          
      return ans[::-1]
</pre>

<p class="text-center text-muted"><a href="https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/" target="_blank">https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/</a></p> 
<pre>
class Solution:
  def zigzagLevelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
      ans = []
      
      if root is None:
          return ans
      
      q = deque([root])

      left_to_right = True
      
      while q:
          level = []
          for _ in range(len(q)):
              
              node = q.popleft()
              level.append(node.val)
                  
              if node.left:
                  q.append(node.left)
              
              if node.right:
                  q.append(node.right)
                  
          if left_to_right:        
              ans.append(level)

          else:
              ans.append(level[::-1])
              
          left_to_right = not left_to_right
          
      return ans
</pre>

<p class="text-center text-muted"><a href="https://leetcode.com/problems/n-ary-tree-level-order-traversal/" target="_blank">https://leetcode.com/problems/n-ary-tree-level-order-traversal/</a></p> 
<pre>
class Solution:
  def levelOrder(self, root: 'Node') -> List[List[int]]:
      ans = []
      
      if root is None:
          return ans
      
      q = deque([root])
      
      while q:
          
          level = []
          for _ in range(len(q)):
              
              cur = q.popleft()
              level.append(cur.val)  
              
              for child in cur.children:
                  q.append(child)
  
          ans.append(level)
          
      return ans
</pre>


<p class="text-center text-muted"><a href="https://leetcode.com/problems/check-completeness-of-a-binary-tree/" target="_blank">https://leetcode.com/problems/check-completeness-of-a-binary-tree/</a></p> 
<pre>
class Solution:
  def isCompleteTree(self, root: Optional[TreeNode]) -> bool:
      q = deque([root])
      
      zero = False
      
      while q:
          cur = q.popleft()
          
          if cur is None:
              zero = True
          
          if zero and cur != None:
              return False
          
          if cur != None:
              q.append(cur.left)
              q.append(cur.right)
              
      return True
</pre>

<p class="text-center text-muted"><a href="https://leetcode.com/problems/find-bottom-left-tree-value/" target="_blank">https://leetcode.com/problems/find-bottom-left-tree-value/</a></p> 
<pre>
class Solution:
  def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:
      q = deque([root])
      
      while q:
          cur = q.popleft()
          
          if cur.right:
              q.append(cur.right)
          
          if cur.left:
              q.append(cur.left)
              
      return cur.val
</pre>


<p class="text-center text-muted"><a href="https://leetcode.com/problems/even-odd-tree/" target="_blank">https://leetcode.com/problems/even-odd-tree/</a></p> 
<pre>
class Solution:
  def isEvenOddTree(self, root: Optional[TreeNode]) -> bool:
      q = deque([root])
      
      level = 0
      
      while q:
          arr = []
          
          for i in range(len(q)):
              cur = q.popleft()
              arr.append(cur.val)
              
              if level % 2 == 0:
                  if arr[i] % 2 == 0:
                      return False
                  if i > 0 and arr[i] <= arr[i - 1]:
                      return False
              else:
                  if arr[i] % 2 != 0:
                      return False
                  if i > 0 and arr[i] >= arr[i - 1]:
                      return False
              
              if cur.left:
                  q.append(cur.left)
                  
              if cur.right:
                  q.append(cur.right)
                  
          level += 1
      
      return True
</pre>


<p class="text-center text-muted"><a href="https://leetcode.com/problems/n-ary-tree-preorder-traversal/" target="_blank">https://leetcode.com/problems/n-ary-tree-preorder-traversal/</a></p> 
<pre>
class Solution:
  def preorder(self, root: 'Node') -> List[int]:
      ans = []
      
      if root is None:
          return ans
      
      stack = [root]
      
      while stack:
          cur = stack.pop()
          
          if cur != None:
              for i in range(len(cur.children) - 1, -1, -1):
                  stack.append(cur.children[i])
              
              stack.append(cur)
              stack.append(None)
          
          else:
              ans.append(stack.pop().val)
              
      return ans
</pre>

<p class="text-center text-muted"><a href="https://leetcode.com/problems/n-ary-tree-postorder-traversal/" target="_blank">https://leetcode.com/problems/n-ary-tree-postorder-traversal/</a></p> 
<pre>
class Solution:
  def postorder(self, root: 'Node') -> List[int]:
      ans = []
      
      if root is None:
          return ans
      
      stack = [root]
      
      while stack:
          cur = stack.pop()
          
          if cur != None:
              stack.append(cur)
              stack.append(None)
              
              for i in range(len(cur.children) - 1, -1, -1):
                  stack.append(cur.children[i])
          
          else:
              ans.append(stack.pop().val)
              
      return ans
</pre>

<p class="text-center text-muted"><a href="https://leetcode.com/problems/binary-tree-right-side-view/" target="_blank">https://leetcode.com/problems/binary-tree-right-side-view/</a></p> 
<pre>
class Solution:
  def rightSideView(self, root: Optional[TreeNode]) -> List[int]:
      ans = []
      
      if root is None:
          return ans
      
      q = deque([root])
      
      while q:
          k = len(q)
          
          for i in range(k):
              cur = q.popleft()
              
              if i == k - 1:
                  ans.append(cur.val)
              
              if cur.left:
                  q.append(cur.left)
                  
              if cur.right:
                  q.append(cur.right)
                  
      return ans
</pre>

<p class="text-center text-muted"><a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/" target="_blank">https://leetcode.com/problems/maximum-depth-of-binary-tree/</a></p> 
<pre>
class Solution:
  def maxDepth(self, root: Optional[TreeNode]) -> int:
      if root is None:
          return 0
      
      return max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1
</pre>

<p class="text-center text-muted"><a href="https://leetcode.com/problems/maximum-depth-of-n-ary-tree/" target="_blank">https://leetcode.com/problems/maximum-depth-of-n-ary-tree/</a></p> 
<pre>
class Solution:
  def maxDepth(self, root: 'Node') -> int:
      if root is None:
          return 0
      
      ans = 1
      
      for child in root.children:
          ans = max(self.maxDepth(child) + 1, ans) 

      return ans
</pre>


<p class="text-center text-muted"><a href="https://leetcode.com/problems/subtree-of-another-tree/" target="_blank">https://leetcode.com/problems/subtree-of-another-tree/</a></p> 
<pre>
class Solution:
  def isSubtree(self, root: Optional[TreeNode], subRoot: Optional[TreeNode]) -> bool:            
      if self.sameTree(root, subRoot):
          return True
      
      return (root.left != None and self.isSubtree(root.left, subRoot)) or (root.right != None and self.isSubtree(root.right, subRoot))
  
  
  def sameTree(self, a, b):
      if a == None and b == None:
          return True

      return a != None and b != None and a.val == b.val and self.sameTree(a.left, b.left) and self.sameTree(a.right, b.right)
</pre>

<p class="text-center text-muted"><a href="https://leetcode.com/problems/symmetric-tree/" target="_blank">https://leetcode.com/problems/symmetric-tree/</a></p> 
<pre>
class Solution:
  def isSymmetric(self, root: Optional[TreeNode]) -> bool:
      if root is None:
          return True
      
      def helper(a, b):
          if a is None and b is None:
              return True
          
          if a is None or b is None:
              return False 
          
          return a.val == b.val and helper(a.left, b.right) and helper(a.right, b.left)
      
      return helper(root.left, root.right)
</pre>

<p class="text-center text-muted"><a href="https://leetcode.com/problems/invert-binary-tree/" target="_blank">https://leetcode.com/problems/invert-binary-tree/</a></p> 
<pre> 
class Solution:
  def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
      if root is None:
          return None
          
      temp = self.invertTree(root.right)
      root.right = self.invertTree(root.left)
      root.left = temp
      
      return root
</pre>

<p class="text-center text-muted"><a href="https://leetcode.com/problems/merge-two-binary-trees/" target="_blank">https://leetcode.com/problems/merge-two-binary-trees/</a></p> 
<pre>
class Solution:
  def mergeTrees(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> Optional[TreeNode]:
      if root1 is None and root2 is None:
          return None
      
      if root1 is None and root2 is not None:
          return root2
      
      if root1 is not None and root2 is None:
          return root1
      
      root1.val += root2.val

      root1.left = self.mergeTrees(root1.left, root2.left)

      root1.right = self.mergeTrees(root1.right, root2.right)
      
      return root1
</pre>


<p class="text-center text-muted"><a href="https://leetcode.com/problems/balanced-binary-tree/" target="_blank">https://leetcode.com/problems/balanced-binary-tree/</a></p> 
<pre>
class Solution:
  def isBalanced(self, root: Optional[TreeNode]) -> bool:
      
      if root is None:
          return True

      if abs(self.height(root.left) - self.height(root.right)) > 1:
          return False
  
      return self.isBalanced(root.left) and self.isBalanced(root.right)
      
      
  def height(self, root):
      
      if root is None:
          return 0
      
      return max(self.height(root.left), self.height(root.right)) + 1
</pre>
 
<p class="text-center text-muted"><a href="https://leetcode.com/problems/flatten-binary-tree-to-linked-list/" target="_blank">https://leetcode.com/problems/flatten-binary-tree-to-linked-list/</a></p> 
<pre>
class Solution:
  def __init__(self):
      self.ans = None
      
  def flatten(self, root: Optional[TreeNode]) -> None:
      if root is None:
          return
      
      self.flatten(root.right)
      self.flatten(root.left)
      
      root.right = self.ans
      root.left = None
      self.ans = root
</pre>

</div>
      </div>
    </div>

    <!-- Footer -->
    <footer class="page-footer font-small blue pt-4">
  
      <!-- Copyright -->
      <div class="footer-copyright text-center py-3">
        
        <div id="disqus_thread"></div>
      </div>
      <!-- Copyright -->
    
    </footer>
    <!-- Footer -->
    
    </div>
    <!-- Scripts --> 

    <script src="https://cdn.rawgit.com/google/code-prettify/master/loader/prettify.js"></script>
    <!-- Script for pocket button -->
    <script type="text/javascript">!function(d,i){if(!d.getElementById(i)){var j=d.createElement("script");j.id=i;j.src="https://widgets.getpocket.com/v1/j/btn.js?v=1";var w=d.getElementById(i);d.body.appendChild(j);}}(document,"pocket-btn-js");</script>
    <!-- Print friendly -->
    <script>var pfHeaderImgUrl = '';var pfHeaderTagline = '';var pfdisableClickToDel = 0;var pfHideImages = 0;var pfImageDisplayStyle = 'right';var pfDisablePDF = 0;var pfDisableEmail = 0;var pfDisablePrint = 0;var pfCustomCSS = '';var pfBtVersion='1';(function(){var js, pf;pf = document.createElement('script');pf.type = 'text/javascript';if ('https:' === document.location.protocol){js='https://pf-cdn.printfriendly.com/ssl/main.js'}else{js='http://cdn.printfriendly.com/printfriendly.js'}pf.src=js;document.getElementsByTagName('head')[0].appendChild(pf)})();</script>
    <!-- Share button / http://sharebutton.co
    <script src="https://cdn.rawgit.com/carrot/share-button/master/src/share-button.js"></script>-->


    <script>
      /**
      *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
      *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables    */
      /*
      var disqus_config = function () {
      this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
      this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
      };
      */
      (function() { // DON'T EDIT BELOW THIS LINE
      var d = document, s = d.createElement('script');
      s.src = 'https://wuyaheng.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
      })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</body>
</html>


